using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Xml;
using System.IO;
using System.Windows.Forms;
using System.Globalization;

namespace BibleFileLib
{
	/// <summary>
	/// This class builds a concordance of a set of XHTML files.
	/// Create a ConcGenerator, giving it the input and output directories and various options.
	/// It processes all the .htm files in the input directory according to the options and produces files in the output directory:
	/// - a file for each wordform found in the processed text of the input files, giving lines of context
	/// - todo: check, expand, correct the following:
	/// - a file for each letter of the alphabet giving the words of those letters
	/// - a master file with the letters of the alphabet.
	/// - todo: check and correct description of how hotlinks are built and connected.
	/// General idea is that eventually all the files generated by this process will be in the same directory.
	/// The parent directory will contain the HTML files with the same content as the XHTML from which the concordance was generated.
	/// Thus, a hot link to ../FileName/anchor will jump the main window to that place in the main document.
	/// Links from letter to words and word to occurrence assume that the concordance files are all in the same directory
	/// and that they are displayed in frames.
	/// </summary>
	public class ConcGenerator
	{
		public enum IndexTypes
		{
			rangeTree, // a tree where the roots are ranges of words, equal in length.
			alphaTree, // a tree where the roots are initial letters of the alphabet.
			alphaTreeMf, // Looks like alphaTree, but done with multiple files for faster loading.
			twoLevelRange // a top-level index using equal word ranges, with multiple second-level files for individual words
		}
		string m_inputDirName;
		string m_outputDirName;
		

        /***********
		// Tuple for storing name and class of open elements.
		class NameClassPair
		{
			public string Name;
			public string Class;
		}
		List<NameClassPair> m_openElementStack = new List<NameClassPair>();
        *************/
		// The information we accumulate during parsing is basically a list of wordforms, each with a list of occurrences,
		// each storing file, chapter, and verse.
		Dictionary<string, WordformInfo> m_occurrences = new Dictionary<string, WordformInfo>();

		// tracks current state
		// string m_inputFile;
		int m_chapter;
		string m_verse;
		string m_anchor; // full text of last anchor seen
		string m_htmlFile; // input file without path and with htm extension.

		int m_wordListFileCount = 1;

		StringBuilder m_context = new StringBuilder();
		List<WordOccurrence> m_pendingOccurrences = new List<WordOccurrence>(); // don't yet have context.

		// Options (currently configured from haiola options right after construction)
		public List<String> Phrases { get; set; } // string that should be processed as phrases (separate entries in concordance)
		public bool MergeCase { get; set; } // true to merge occurrence lists for words differing only by case
		public string WordformingChars { get; set; } // overrides, list of characters that should be considered word-forming in defiance of Unicode.
		public int MaxFrequency { get; set; } // exclude words occurring more often than this.
		public HashSet<string> ExcludeWords { get; set; } // words to exclude from concordance
		public int MaxContextLength { get; set; } // max chars of context to include before and after target word
		public int MinContextLength { get; set; } // min chars of context to include before and after target word (if present in sentence)
		/// <summary>
		/// Key is canonical three-letter code for book, used at start of file name.
		/// Value is alternative text to use to identify book in concordance references.
		/// </summary>
		public Dictionary<string, string> ReferenceAbbeviationsMap { get; set; } 

		// Todo: following options need a way to configure them in the Haiola UI.
		public string ConcordanceLinkText { get; set; } // string displayed as a hot link to bring up the concordance.
		public HashSet<string> ExcludeClasses { get; set; } // exclude contents of elements with these classes from concordance
		public HashSet<string> NonCanonicalClasses = new HashSet<string>(); // elements with these classes are not canonical (but are concorded)
		public string NotesClass { get; set; } // element with this class contains footnotes; references should not be output.
		public string NotesRef { get; set; } // use this string as the 'reference' for words within notesClass.
		public string HeadingRef { get; set; } // use this string as the 'reference' for other non-Canonical words.
		public IndexTypes IndexType { get; set; } // which kind of index to generate; see definition of IndexTypes.
		public string BookChapText { get; set; } // text for the 'Books and Chapters' hot link, from options file.
		public IComparer<string> Comparer { get; set; } // used to sort words in the concordance. May be configured directly or using CompareId.


		List<string> m_pendingExclusions = new List<string>(); // names of elemenents opened that must close before we restart.
		List<string> m_pendingNonCanonical = new List<string>(); // names of open elemenents that indicate non-canonical text.
		// Entries represent wordforms in lower case (wordform.ToLower()) where we have not yet encountered a lowercase version
		// of the word in the text, but have encountered an other-case version. Key is the lowercase version, value is the
		// uppercase version.
		// If we encounter two uppercase versions which map to the same LC wordform we arbitrarily use the one that occurs first.
		Dictionary<string, string> m_uppercaseForms = new Dictionary<string, string>();

		public ConcGenerator(string inputDirName, string outputDirName)
		{
			m_inputDirName = inputDirName;
			m_outputDirName = outputDirName;

			IndexType = IndexTypes.alphaTreeMf;
			MaxFrequency = Int32.MaxValue;
			MaxContextLength = 50;
			MinContextLength = 35;
			ExcludeWords = new HashSet<string>();
			ExcludeClasses = new HashSet<string>(); // todo: initialize
			NonCanonicalClasses = new HashSet<string>(); // todo: initialize
			BookChapText = "Books and Chapters";
			ConcordanceLinkText = "Concordance";
			Comparer = StringComparer.InvariantCultureIgnoreCase;
		}

		private string m_comparerId;
		/// <summary>
		///  A way of specifing a Comparer indirectly using a string which may be one of
		///  - a culture identifier which may be passed to the constructor of CultureInfo
		/// Two other options are currently disabled as they bring in a dependency on Palaso library:
		///  - CustomSimple:id, where id is a string that may be passed to Palaso.WritingSystems.Collation.SimpleRulesCollator
		///  - CustomICU:id, where id is a string that may be passed to Palaso.WritingSystems.Collation.IcuRulesCollator
		/// </summary>
		/// Note: CompareId may be read only if it has been set; it does not have a useful value if Comparer is set directly.
		public string ComparerId
		{
			get { return m_comparerId; }
			set
			{
				m_comparerId = value;
				if (value == null)
					return;
				var parts = value.Split(':');
				if (parts.Length == 1) // no colon, it's an explicit culture identifier, we hope.
				{
					try
					{
						CultureInfo info = new CultureInfo(value);
						Comparer = StringComparer.Create(info, true);
					}
					catch (ArgumentException)
					{
						MessageBox.Show("Cannot interpret " + value + " as a collation ID. Using default collation.", "Error", MessageBoxButtons.OK,
							MessageBoxIcon.Warning);
					}				
				}
				//Debug.Assert(parts.Length == 2); // Enhance: report somehow
				//var compareId = parts[0];
				//if (compareId == "CustomSimple")
				//{
				//    Comparer = new Palaso.WritingSystems.Collation.SimpleRulesCollator(parts[1]);
				//}
				//else if (compareId == "CustomICU")
				//{
				//    Comparer = new Palaso.WritingSystems.Collation.IcuRulesCollator(parts[1]);
				//}
				// Enhance: report somehow.
			}
		}

		public static string Stage { get; internal set; }

		private static string m_progress;

		public static string Progress
		{
			get { return m_progress; }
			internal set
			{
				m_progress = value;
				Application.DoEvents(); // allows timer to fire and update progress report in main window.
			}
		}

		/// <summary>
		/// Run the concordance building process on the specified list of files (file names only, in the input directory)
		/// </summary>
		/// <param name="verseTextName">Name of the verseText file to parse</param>
		public void Run(string verseTextName)
		{
			//Progress status = new Progress(files.Count);
			//Utils.EnsureDirectory(m_outputDirName);
			Stage = "Parsing";
			int count = 0;
            Parse(verseTextName);
            /*
			foreach (string inputFile in files)
			{
				Progress = inputFile;
				string inputFilePath = Path.Combine(m_inputDirName, inputFile);
					Parse(inputFilePath); 
				count++;
			}
            */ 

			// Use the individual word occurrences to find phrase occurrences (and add them before sorting etc.)
			AddPhraseOccurrences();
			
			List<WordformInfo> sortedOccurrences = new List<WordformInfo>(m_occurrences.Count);
			foreach (WordformInfo info in m_occurrences.Values)
			{
				if (info.Occurrences.Count > MaxFrequency)
					continue;
				if (ExcludeWords.Contains(info.Form))
					continue;
				sortedOccurrences.Add(info);
			}
			Stage = "Sorting";
			Progress = "";
			sortedOccurrences.Sort(new WordformInfoComparer(Comparer));
			//status = new Progress(sortedOccurrences.Count);
			Stage = "Generating";
			count = 0;
			// Must do this before making index files, it sets FileNumber property in each item.
			foreach (WordformInfo item in sortedOccurrences)
			{
				MakeOccurrenceFile(item);
				if (count % 10 == 0)
				{
					Progress = item.Form;
				}
				count++;
			}

			switch (IndexType)
			{
				case IndexTypes.twoLevelRange:
					MakeIndexFiles(sortedOccurrences);
					break;
				case IndexTypes.rangeTree:
					MakeTreeRangeIndex(sortedOccurrences);
					break;
				case IndexTypes.alphaTree:
					MakeAlphaIndex(sortedOccurrences);
					break;
				case IndexTypes.alphaTreeMf:
					MakeAlphaMfIndex(sortedOccurrences);
					break;
			}
		}

		private void MakeIndexFiles(List<WordformInfo> sortedOccurrences)
		{
			double count = sortedOccurrences.Count;
			int groupSize = Convert.ToInt32(Math.Sqrt(count));
			int iStartGroup = 0;
			string header = "<!doctype HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n"
                + "<html>\n<head>\n<meta name=\"robots\" content=\"noindex, nofollow\"><meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n</head>\n<body>\n";
			string trailer = "</body>\n</html>\n";
			string pathMain = Path.Combine(m_outputDirName, "concIndexBar.htm");
			TextWriter writerMain = new StreamWriter(pathMain, false, Encoding.UTF8);
			writerMain.Write(header);

			int groupIndex = 1;
			for (int cGroupsRemaining = groupSize; cGroupsRemaining > 0; cGroupsRemaining--)
			{
				// Enhance: adjust group size to give better breakdown, e.g., by first letter or first two letters.
				int cThisGroup = (sortedOccurrences.Count - iStartGroup) / cGroupsRemaining;
				if (cThisGroup > 0)
				{
					string groupFileName = "index" + groupIndex + ".htm";
					WordformInfo firstItemInGroup = sortedOccurrences[iStartGroup];
					WordformInfo lastItemInGroup = sortedOccurrences[iStartGroup + cThisGroup - 1];
					writerMain.Write("<a href=\"{0}\" target=\"inner\">{1} - {2}</a><br/>\n",
						new object[] { groupFileName, MakeSafeXml(firstItemInGroup.Form), MakeSafeXml(lastItemInGroup.Form) });
					WriteInnerIndexFile(groupFileName, sortedOccurrences, groupIndex, iStartGroup, cThisGroup);
				}
				iStartGroup += cThisGroup;
				groupIndex++;
			}
			writerMain.Write(trailer);
			writerMain.Close();
		}

		/// <summary>
		/// Fix the string to be safe in a text region of XML. (From Utils.cs; can we fix duplication?)
		/// </summary>
		/// <param name="sInput"></param>
		/// <returns></returns>
		public static string MakeSafeXml(string sInput)
		{
			string sOutput = sInput;

			if (sOutput != null && sOutput.Length != 0)
			{
				sOutput = sOutput.Replace("&", "&amp;");
				sOutput = sOutput.Replace("<", "&lt;");
				sOutput = sOutput.Replace(">", "&gt;");
			}
			return sOutput;
		}
		const string indexHeader = "<!doctype HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n"
                + "<html>\n<head>\n<meta name=\"robots\" content=\"noindex, nofollow\"><meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n"    
				+ "<link rel=\"stylesheet\" type=\"text/css\" href=\"mktree.css\">\n"
				+ "<link rel=\"stylesheet\" href=\"display.css\" type=\"text/css\">\n"
				+ "<script type=\"text/javascript\" src=\"mktree.js\"></script>\n</head>\n"
				+ "<body class=\"ConcIndex\">\n"
				+ "<p><a target=\"_top\" href=\"../index.htm\">";
		const string indexHeader2 = "</a></p>\n"
				+ "<ul class=\"mktree\">\n";
		const string indexTrailer = "</ul>\n</body>\n</html>\n";

		/// <summary>
		/// Make tree-organization index with equal ranges of words as the roots.
		/// </summary>
		/// <param name="sortedOccurrences"></param>
		private void MakeTreeRangeIndex(List<WordformInfo> sortedOccurrences)
		{
			double count = sortedOccurrences.Count;
			int groupSize = Convert.ToInt32(Math.Sqrt(count));
			int iStartGroup = 0;

			string pathMain = Path.Combine(m_outputDirName, "concTreeIndex.htm");
			TextWriter writerMain = new StreamWriter(pathMain, false, Encoding.UTF8);

            string ciHeaderPath = Path.Combine(Path.GetDirectoryName(m_inputDirName), "concIndexHeader.txt");
            if (File.Exists(ciHeaderPath))
            {
                string headerFmt = new StreamReader(ciHeaderPath, Encoding.UTF8).ReadToEnd();
                writerMain.Write(string.Format(headerFmt, ConcordanceLinkText));
            }
            else
            {
                writerMain.Write(indexHeader);
                writerMain.Write(BookChapText);
                writerMain.Write(indexHeader2);               
            }

			int groupIndex = 1;
			for (int cGroupsRemaining = groupSize; cGroupsRemaining > 0; cGroupsRemaining--)
			{
				// Enhance: adjust group size to give better breakdown, e.g., by first letter or first two letters.
				int cThisGroup = (sortedOccurrences.Count - iStartGroup) / cGroupsRemaining;
				if (cThisGroup > 0)
				{
					WordformInfo firstItemInGroup = sortedOccurrences[iStartGroup];
					WordformInfo lastItemInGroup = sortedOccurrences[iStartGroup + cThisGroup - 1];
					writerMain.Write("<li>{0} - {1}<ul>\n",
						new object[] { MakeSafeXml(firstItemInGroup.Form), MakeSafeXml(lastItemInGroup.Form) });
					WriteInnerIndexItems(writerMain, sortedOccurrences, iStartGroup, cThisGroup);
					writerMain.Write("</ul></li>\n");
				}
				iStartGroup += cThisGroup;
				groupIndex++;
			}
            string ciFooterPath = Path.Combine(Path.GetDirectoryName(m_inputDirName), "concIndexFooter.txt");
            if (File.Exists(ciFooterPath))
            {
                string fmt = new StreamReader(ciFooterPath, Encoding.UTF8).ReadToEnd();
                writerMain.Write(string.Format(fmt, ConcordanceLinkText));
            }
            else
            {
                writerMain.Write(indexTrailer);
            }
			writerMain.Close();
		}
		/// <summary>
		/// Make tree-organization index with letters of alphabet as roots.
		/// </summary>
		/// <param name="sortedOccurrences"></param>
		private void MakeAlphaIndex(List<WordformInfo> sortedOccurrences)
		{
			int iStartGroup = 0;

			string pathMain = Path.Combine(m_outputDirName, "concTreeIndex.htm");
			TextWriter writerMain = new StreamWriter(pathMain, false, Encoding.UTF8);
			writerMain.Write(indexHeader);
			writerMain.Write(BookChapText);
			writerMain.Write(indexHeader2);

			while (iStartGroup < sortedOccurrences.Count)
			{
				string keyLetter = sortedOccurrences[iStartGroup].Form.Substring(0, 1).ToUpper();
				// Enhance JohnT: handle surrogate pair or multigraph.
				int iLimGroup = iStartGroup + 1;
				while (iLimGroup < sortedOccurrences.Count &&
					sortedOccurrences[iLimGroup].Form.Substring(0, keyLetter.Length).ToUpper() == keyLetter)
				{
					iLimGroup++;
				}
				writerMain.Write("<li><span class=\"indexKeyLetter\">{0}</span><ul>\n", MakeSafeXml(keyLetter));
				WriteInnerIndexItems(writerMain, sortedOccurrences, iStartGroup, iLimGroup - iStartGroup);
				writerMain.Write("</ul></li>\n");
				iStartGroup = iLimGroup;
			}
			writerMain.Write(indexTrailer);
			writerMain.Close();
		}
		const string indexMfHeader = "<!doctype HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n"
            + "<html>\n"
            + "<head>\n<meta name=\"robots\" content=\"noindex, nofollow\"><meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n"
			+ "<link rel=\"stylesheet\" type=\"text/css\" href=\"mktree.css\">\n"
			+ "<link rel=\"stylesheet\" href=\"display.css\" type=\"text/css\">\n"
			+ "</head>\n"
			+ "<body class=\"ConcIndex\">\n"
			+ "<p><a target=\"_top\" href=\"../index.htm\">";
		const string indexMfHeader2 = "</a></p>\n"
				+ "<ul class=\"mktree\">\n";
		/// <summary>
		/// Make tree-organization index with letters of alphabet as roots.
		/// </summary>
		/// <param name="sortedOccurrences"></param>
		private void MakeAlphaMfIndex(List<WordformInfo> sortedOccurrences)
		{
			string pathMain = Path.Combine(m_outputDirName, "concTreeIndex.htm");
			MakeAlphaMfIndexItem(sortedOccurrences, pathMain, pathMain, null);
		}

		/// <summary>
		/// Write one of the indexes that together make up the multi-file alphabetic index.
		/// If expandLetter is null, also write the subfiles. Otherwise, expand that one letter.
		/// </summary>
		/// <param name="sortedOccurrences"></param>
		/// <param name="pathMain"></param>
		/// <param name="expandLetter"></param>
		private void MakeAlphaMfIndexItem(List<WordformInfo> sortedOccurrences, string pathMain, string pathRoot, string expandLetter)
		{
			int iStartGroup = 0;
			TextWriter writerMain = new StreamWriter(pathMain, false, Encoding.UTF8);
            string ciHeaderPath = Path.Combine(Path.GetDirectoryName(m_inputDirName), "concIndexHeader.txt");
            if (File.Exists(ciHeaderPath))
            {
                string headerFmt = new StreamReader(ciHeaderPath, Encoding.UTF8).ReadToEnd();
                writerMain.Write(string.Format(headerFmt, ConcordanceLinkText));
            }
            else
            {
                writerMain.Write(indexMfHeader);
                writerMain.Write(BookChapText);
                writerMain.Write(indexHeader2);
            }

		    while (iStartGroup < sortedOccurrences.Count)
			{
				string keyLetter = GetSortLetter(sortedOccurrences[iStartGroup].Form);
				// Enhance JohnT: handle surrogate pair or multigraph. (See keyLetterFileSuffix below, too.)
				int iLimGroup = iStartGroup + 1;
				while (iLimGroup < sortedOccurrences.Count &&
					GetSortLetter(sortedOccurrences[iLimGroup].Form) == keyLetter)
				{
					iLimGroup++;
				}
				// We want a predictable file suffix but not one that might be some non-Roman character.
				// This needs enhancing for surrogate pairs, too.
				string keyLetterFileSuffix = Convert.ToInt32(keyLetter[0]).ToString();
				string keyLetterPath = Path.Combine(m_outputDirName, "Index" + keyLetterFileSuffix + ".htm");
				if (expandLetter == keyLetter)
				{
					writerMain.Write("<li class=\"liOpen\"><span id=\"open\" class=\"indexKeyLetter\"><span class=\"bullet\" onclick=\"location='{1}#open'\">&nbsp;</span><a href=\"{1}\">{0}</a></span><ul>\n",
						MakeSafeXml(keyLetter), Path.GetFileName(pathRoot));
					WriteInnerIndexItems(writerMain, sortedOccurrences, iStartGroup, iLimGroup - iStartGroup);
					writerMain.Write("</ul></li>\n");
				}
				else
				{
					// write an element that looks like a closed node, but is actually a hotlink to another index file.
					// (And do NOT write the subitems!)
					writerMain.Write("<li class=\"liClosed\"><span class=\"indexKeyLetter\"><span class=\"bullet\"onclick=\"location='{1}'\">&nbsp;</span><a href=\"{1}#open\">{0}</a></span></li>\n",
						MakeSafeXml(keyLetter), Path.GetFileName(keyLetterPath));
				}
				if (expandLetter == null)
				{
					MakeAlphaMfIndexItem(sortedOccurrences, keyLetterPath, pathRoot, keyLetter);
				}
				iStartGroup = iLimGroup;
			}
            string ciFooterPath = Path.Combine(Path.GetDirectoryName(m_inputDirName), "concIndexFooter.txt");
            if (File.Exists(ciFooterPath))
            {
                string fmt = new StreamReader(ciFooterPath, Encoding.UTF8).ReadToEnd();
                writerMain.Write(string.Format(fmt, ConcordanceLinkText));
            }
            else
            {
                writerMain.Write(indexTrailer);
            }
		    writerMain.Close();
		}

		// Get a string representing the leading letter for a sort group.
		// Todo: handle surrogate pairs.
		private string GetSortLetter(string form1)
		{
			// Decomposing the string will leave the base character as the one we break on, if any words start with
			// characters that are composed with diacritics. Otherwise, for example, since the A and A-acute words may have primary
			// sort differences further along the word, we get an alternation between A and A-acute, and hence several groups for each.
			string form = form1.Normalize(NormalizationForm.FormD);
			//return form.Substring(0, 1).ToUpper()
			for (int i = 0; i < form.Length; i++)
			{
				System.Globalization.UnicodeCategory[] goodCategories = new System.Globalization.UnicodeCategory[]
				{
					System.Globalization.UnicodeCategory.LowercaseLetter,
					System.Globalization.UnicodeCategory.OtherLetter,
					// probably wordforming, but probably mess up sorting. Better to leave out than break groups,
					// until we have a better sort algorithm.
					//System.Globalization.UnicodeCategory.PrivateUse, 
					System.Globalization.UnicodeCategory.TitlecaseLetter,
					System.Globalization.UnicodeCategory.UppercaseLetter
				};
				char c = form[i];
				for (int j = 0; j < goodCategories.Length; j++)
				{
					if (Char.GetUnicodeCategory(c) == goodCategories[j])
						return c.ToString().ToUpper();
				}
			}
			return form[0].ToString().ToUpper(); // desperate resort!
		}

		private void WriteInnerIndexItems(TextWriter writer, List<WordformInfo> sortedOccurrences,
			int iStartGroup, int cThisGroup)
		{
			for (int i = iStartGroup; i < iStartGroup + cThisGroup; i++)
			{
				WordformInfo item = sortedOccurrences[i];
				writer.Write("<li><a href=\"wl{0}.htm\" target=\"conc\">{1} ({2})</a></li>\n",
					new object[] { item.FileNumber, MakeSafeXml(item.Form), item.Occurrences.Count });
			}
		}

		private void WriteInnerIndexFile(string groupFileName, List<WordformInfo> sortedOccurrences, int groupIndex,
			int iStartGroup, int cThisGroup)
		{
			string header = "<!doctype HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n"
                + "<html>\n<head>\n<meta name=\"robots\" content=\"noindex, nofollow\"><meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\"></head>\n"
                + "<body>\n";
			string trailer = "</body>\n</html>\n";
			string path = Path.Combine(m_outputDirName, "index" + groupIndex + ".htm");
			TextWriter writer = new StreamWriter(path, false, Encoding.UTF8);
			writer.Write(header);

			for (int i = iStartGroup; i < iStartGroup + cThisGroup; i++)
			{
				WordformInfo item = sortedOccurrences[i];
				writer.Write("<a href=\"wl{0}.htm\" target=\"conc\">{1}</a><br/>\n",
					new object[] { item.FileNumber, MakeSafeXml(item.Form) });
			}
			writer.Write(trailer);
			writer.Close();
		}

        /// <summary>
        /// Replaces null strings with the empty string, but passes non-null strings through.
        /// </summary>
        /// <param name="s">any string</param>
        /// <returns>s if not null, otherwise the empty string</returns>
        public static string nonull(string s)
        {
            if (s == null)
                return String.Empty;
            else
                return s;
        }

        /// <summary>
        /// Parse an XML verseText file containing searchable text strings of canonical Bible content
        /// into concordance words. The verseText XML file contains only the canonical text contained
        /// within verses + canonical Psalm titles (always considered part of the following verse 1),
        /// all contained within "v" elements, with book, chapter, and verse attributes called "b",
        /// "c", and "v", respectively. This file is used instead of the USFX file it was derived from
        /// because (1) it is easier, (2) that file needed to be produced anyway for full text
        /// search capabilities on a more advanced web site, and (3) it localizes the process for
        /// extracting unformatted canonical text to just one place in the ExtractSearchText class,
        /// making errors less likely.
        /// </summary>
        /// <param name="inputFile">full path name of verseText.xml</param>
		private void Parse(string inputFile)
		{
            XmlTextReader vt;
            string currentBookId = String.Empty;
            string currentChapter = String.Empty;
            string firstVerse = String.Empty;
            m_verse = String.Empty;
            string currentURL = String.Empty;
            string chapFormat = "00";
            m_chapter = 0;
            int verseNumber = 0;

            m_pendingNonCanonical.Clear();
            m_pendingExclusions.Clear();
            m_context.Remove(0, m_context.Length);

            try
            {
                vt = new XmlTextReader(inputFile);
                vt.WhitespaceHandling = WhitespaceHandling.All;
                while (vt.Read())
                {
                    // Console.Write("{0} {1}:{2} {3}       \r", currentBookAbbrev, currentChapter, currentVerse, localSubstLine);

                    if ((vt.NodeType == XmlNodeType.Element) && (vt.Name == "v"))
                    {
                        currentBookId =  nonull(vt.GetAttribute("b"));
                        currentChapter = nonull(vt.GetAttribute("c"));
                        m_verse = nonull(vt.GetAttribute("v"));
                        if (currentBookId.CompareTo("PSA") == 0)
                            chapFormat = "000";
                        else
                            chapFormat = "00";
                        int chNum;
                        if (Int32.TryParse(currentChapter, out chNum))
                            m_chapter = chNum;
                        else
                            MessageBox.Show("Bad chapter number " + currentChapter + " in " + inputFile + " " + currentBookId);
                        int vnum;
                        // Verse numbers might be verse bridges, like "20-22" or simple numbers, like "20".
                        firstVerse = m_verse;
                        vnum = firstVerse.IndexOf('-');
                        if (vnum > 0)
                            firstVerse = firstVerse.Substring(0, vnum);
                        if (firstVerse.Length > 0)
                        {
                            if (Int32.TryParse(firstVerse, out vnum))
                            {
                                verseNumber = vnum;
                            }
                            else
                            {
                                MessageBox.Show("Bad verse number " + m_verse + " in " + inputFile + " " + currentBookId + ":" + currentChapter);
                            }
                        }
                        else
                        {
                            verseNumber = 0;
                        }
                        currentURL = String.Format("../{0}{1}.htm#V{2}", currentBookId,
                            Math.Max(1, m_chapter).ToString(chapFormat), verseNumber.ToString());
                        m_anchor = String.Format("V{0}", verseNumber.ToString());
                        m_htmlFile = String.Format("{0}{1}.htm", currentBookId,
                            Math.Max(1, m_chapter).ToString(chapFormat));
                        if (!vt.IsEmptyElement)
                        {
                            vt.Read();
                            if ((vt.NodeType == XmlNodeType.Text) || (vt.NodeType == XmlNodeType.SignificantWhitespace))
                            {
                                ProcessText(vt.Value);
                            }
                        }
                    }
                }
                ProcessEndOfSentence(); // In case text does not end with sentence-final punctuation, don't want wordforms with no context.
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.Message + "\r\n" + ex.StackTrace, "Error parsing " + inputFile);
            }

		}

        /// <summary>
        /// Call this whenever the key factors we use in determining an occurrence are about to change, to build occurrences
        /// for whatever verse text we have accumulated. Then reset verseText.
        /// If we don't have a workable URL for this verseText, we will output those words later, as part of the next verse.
        /// </summary>
        /// <param name="verseText"></param>
        /// <param name="currentURL"></param>
        /* Not currently used.
	    private void ProcessVerseText(StringBuilder verseText, string currentURL)
	    {
	        if ((currentURL.Length > 13) && (verseText.Length > 0))
	        {
	            ProcessText(verseText.ToString());
                verseText.Length = 0;
            }
        }
        */

	    /// <summary>
		/// Make an HTML file containing the occurrences of a particular wordform, with links to the text and click actions
		/// to highlight the key word in the destination file.
		/// 
		/// Enhance: now we have the global variables for curWord and curFlags, we needn't pass that as arguments
		/// to the individual sel() functions, which will make files smaller.
		/// We could make a global variable indicating the current word in the main text pane, and only run
		/// the algorithm when it changes. That would save compute time on the client.
		/// </summary>
		/// <param name="info"></param>
		private void MakeOccurrenceFile(WordformInfo info)
		{
			List<WordOccurrence> items = info.Occurrences;
			string flags = info.MixedCase ? "i" : "";
			string infoForm = MakeSafeXml(info.Form);
			string fixQuoteInfoForm = infoForm.Replace("'", "&#39"); // apostrophe in word can close onclick quote.
			string header = "<!doctype HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n"
                + "<html>\n"
                + "<head>\n<meta name=\"robots\" content=\"noindex, nofollow\"><meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n"
				+ "<script src=\"ConcFuncs.js\" type=\"text/javascript\"></script>\n"
				+ "<link rel=\"stylesheet\" type=\"text/css\" href=\"display.css\">\n"
			    + "</head>\n<body>\n";
			string trailer = "</body>\n</html>\n";
			string path = Path.Combine(m_outputDirName, "wl" + m_wordListFileCount.ToString() + ".htm");
			info.FileNumber = m_wordListFileCount;
			m_wordListFileCount++;
			TextWriter writer = new StreamWriter(path, false, Encoding.UTF8);
			writer.Write(header);
			foreach (WordOccurrence item in items)
			{
				writer.Write("<span class=\"OccRef\">");
				if (item.Canonical)
				{
					writer.Write(GetAbbreviation(item.FileName));
					writer.Write(" ");
					writer.Write(item.Chapter);
					writer.Write(".");
					writer.Write(MakeSafeXml(item.Verse));
					writer.Write(": ");
				}
				else if (item.Verse == "")
					writer.Write(NotesRef); // in Notes area.
				else
					writer.Write(HeadingRef); // other option for now is some sort of heading.
				writer.Write("</span>");
				if (!item.Canonical)
				{
					writer.Write("<span class=\"special\">");
				}
				WritePrecedingContext(writer, item.Context.Substring(0, item.Offset));
				string form = MakeSafeXml(item.Form);
				string fixQuoteForm = form.Replace("'", "&#39"); // apostrophe in word can close onclick quote.
				// We write the word and flags that are needed for highlighting the selected word as parameters of the href.
				// This has no effect on which file is displayed, but the JavaScript invoked by the onLoad method of the scripture page
				// can extract this from the HTML (see onLoad method of TextFuncs.js) and use it to highlight the selected word.
				// We use this rather than the old strategy of encoding the selected word in a variable of the occurrences pane
				// because (a) we are no longer showing both panes at once; and (b) they are now in different directories, which
				// leads to security errors, at least when using the files offline.
				writer.Write("<a href=\"../{0}?w={5}&amp;f={3}#{1}\">{4}</a>", // FixMe: nestConc: ../
					new object[] { item.FileName, item.Anchor, fixQuoteForm, flags, form, infoForm});
				//writer.Write(item.Context.Substring(item.Offset + key.Length, item.Context.Length - item.Offset - key.Length));
				WriteFollowingContext(writer, item.Context.Substring(item.Offset + info.Form.Length, item.Context.Length - item.Offset - info.Form.Length));
				if (!item.Canonical)
				{
					writer.Write("</span>");
				}
				writer.Write("<br/>\n");
			}
			writer.Write(trailer);
			writer.Close();
		}

		private string GetAbbreviation(string fileName)
		{
			string standardName =  fileName.Substring(0, Math.Min(3, fileName.Length));
			string result;
			if (ReferenceAbbeviationsMap == null || !ReferenceAbbeviationsMap.TryGetValue(standardName, out result))
				return standardName;
			return result;
		}

		private void WritePrecedingContext(TextWriter writer, string context)
		{
			if (context.Length < MaxContextLength)
			{
				writer.Write(MakeSafeXml(context));
				return;
			}
			int iWhiteSpace = -1;
			for (int i = context.Length - MaxContextLength; i < context.Length - MinContextLength; i++)
			{
				if (Char.IsWhiteSpace(context[i]))
				{
					iWhiteSpace = i + 1;
					break;
				}
			}
			if (iWhiteSpace > 0)
			{
				while (iWhiteSpace < context.Length && Char.IsWhiteSpace(context[iWhiteSpace]))
					iWhiteSpace++;
				writer.Write(MakeSafeXml(context.Substring(iWhiteSpace, context.Length - iWhiteSpace)));
			}
			else
			{
				writer.Write("...");
				writer.Write(MakeSafeXml(context.Substring(context.Length - MaxContextLength + 3, MaxContextLength - 3)));
			}
		}

		private void WriteFollowingContext(TextWriter writer, string context)
		{
			if (context.Length < MaxContextLength)
			{
				writer.Write(MakeSafeXml(context));
				return;
			}
			int iWhiteSpace = -1;
			for (int i = MaxContextLength - 1; i >= MinContextLength; i--)
			{
				if (Char.IsWhiteSpace(context[i]))
				{
					iWhiteSpace = i;
					break;
				}
			}
			if (iWhiteSpace >= 0)
			{
				while (iWhiteSpace > 0 && Char.IsWhiteSpace(context[iWhiteSpace - 1]))
					iWhiteSpace--;
				writer.Write(MakeSafeXml(context.Substring(0, iWhiteSpace)));
			}
			else
			{
				writer.Write(MakeSafeXml(context.Substring(0, MaxContextLength - 3)));
				writer.Write("...");
			}
		}

		private bool IsLetter(char c)
		{
			if (WordformingChars.IndexOf(c) >= 0)
				return true;
			return Char.IsLetter(c);
		}

		// The class of the most recent still-open element which has a class.
        /***********
		private string CurrentClass
		{
			get
			{
				for (int i = m_openElementStack.Count - 1; i >= 0; i--)
				{
					if (m_openElementStack[i].Class != null)
						return m_openElementStack[i].Class;
				}
				return null;
			}
		}
        **********/

		private void ProcessText(string text)
		{
            /*****
			if (CurrentClass == "chapterlabel") // Enhance JohnT: Make this configurable.
			{
				int temp;
				if (Int32.TryParse(text.Trim(), out temp))
					m_chapter = temp;
				// else report problem somehow?
			}
			if (m_chapter < 0 || m_pendingExclusions.Count > 0)
				return; // not currently Scripture text we want to concord (or include in context).
             ***/
			EnsureWhiteSpaceEndsContext();
			char prev = ' ';
			int startWord = -1;
			int added = 0; // index of first character not yet added to context.
			for (int i = 0; i < text.Length; i++)
			{
				char current = text[i];
				if (IsLetter(current))
				{
					if (!IsLetter(prev))
					{
						// start of word
						startWord = i;
						added = UpdateContext(text, added, i);
					}
				}
				else
				{
					if (IsLetter(prev))
					{
						// end of word. Note that this check must be BEFORE we do any special handling related to
						// the exact nature of the following character.
						string wordform = text.Substring(startWord, i - startWord);
						ProcessWordform(wordform);
					}
					if (current == '.' || current == '!' || current == '?') // enhance JohnT: more generaly sentence separator set.
					{
						added = UpdateContext(text, added, i + 1); // include the punctuation
						ProcessEndOfSentence();
					}
					else if (current == '\n')
					{
						// add any non-wordforming text we already processed
						added = UpdateContext(text, added, i);
						added++; // so we won't subsequently copy the newline
						// If there's something there and it isn't already white space, put a space in the context
						// to stand for the linebreak.
						EnsureWhiteSpaceEndsContext();
					}
				}
				prev = current;
			}
			if (IsLetter(prev))
			{
				// process final wordform
				string wordform = text.Substring(startWord, text.Length - startWord);
				ProcessWordform(wordform);
			}
			UpdateContext(text, added, text.Length);
		}

		/// <summary>
		/// About to add text following markup or newline to the context; insert a space if it doesn't end
		/// with something white.
		/// </summary>
		private void EnsureWhiteSpaceEndsContext()
		{
			if (m_context.Length != 0 && !Char.IsWhiteSpace(m_context[m_context.Length - 1]))
			{
				m_context.Append(' ');
			}
		}

		private int UpdateContext(string text, int added, int i)
		{
			m_context.Append(text.Substring(added, i - added));
			added = i;
			return added;
		}

		string m_saveContext = "";

		/// <summary>
		/// We've just added end-of-sentence punctuation to the context.
		/// Set it as the context of any pending wordforms, and reset it.
		/// </summary>
		private void ProcessEndOfSentence()
		{
			string context = m_context.ToString();
			m_context.Remove(0, m_context.Length); // reset for next time
			int cInitialPunct = 0;
			// This loop strips from the start of context trailing punctuation from the previous sentence.
			// The loop terminates when it finds a non-punctuation non-white character.
			// The correction is made only if we find a white space character following some punctuation
			// before the first non-white.
			// The bit to strip from this context is everything up to the last white space character before
			// the first non-white non-punct.
			for (int i = 0; i < context.Length; i++)
			{
				if (Char.IsWhiteSpace(context[i]))
				{
					cInitialPunct = i + 1;
					continue;
				}
				if (!Char.IsPunctuation(context[i]))
					break;
			}
			string nextSave = "";
			if (cInitialPunct > 0)
			{
				// Save for next context stuff up to and including character cSave
				int cSave = cInitialPunct - 1;
				while (cSave > 0 && (cSave >= context.Length - 1 || Char.IsWhiteSpace(context[cSave + 1])))
					cSave--;
				nextSave = context.Substring(0, cSave);
			}
			string newContext = context.Substring(cInitialPunct) + m_saveContext;
			m_saveContext = nextSave;
			foreach (WordOccurrence w in m_pendingOccurrences)
			{
                if (cInitialPunct <= w.Offset)
                {
                    // Normally we should be able to remove the previous sentence punctuation and leave w.Offset valid.
                    w.Context = newContext;
                    w.Offset = w.Offset - cInitialPunct;
                }
                else
                {
                    // pathologically the occurrence might just possibly be within what we thought was previous sentence punctuation.
                    // If so remove as much as we can, and add the usual.
                    w.Context = context.Substring(w.Offset) + m_saveContext;
                    w.Offset = 0;
                }
			}
			m_pendingOccurrences.Clear();
		}

		private void ProcessWordform(string wordform)
		{
			WordformInfo info;
			if (!m_occurrences.TryGetValue(wordform, out info))
			{
				if (MergeCase)
				{
					string wordformLC = wordform.ToLower(System.Globalization.CultureInfo.InvariantCulture); // review JohnT: should we select a culture?
                    // Michael: unfortunately, we often process texts that don't fit an existing culture. The InvariantCulture is a compromise and a good
                    // default, and probably good enough in finding the right lower case character for any language.
					if (wordformLC != wordform)
					{
						// It's an upper case form of some sort.
						if (m_occurrences.TryGetValue(wordformLC, out info))
						{
							// We already have an entry for the LC version of this word; the new occurrence just gets added to it.
							// This accomplishes the merging of cases. Note that we do have a mixture, if we don't already know it.
							info.MixedCase = true;
						}
						else
						{
							// We don't have an entry for the LC version of the word. Do we have one for some other UC version?
							string existingUCform;
							if (m_uppercaseForms.TryGetValue(wordformLC, out existingUCform))
							{
								// bizarre...we have more than one UC version of the wordform, since we don't have an entry for the current
								// one but do for SOME UC version. Use the existing one. This makes it a bit arbitraray whether we will get an
								// entry for 'James' or 'JAMES' if both occur, but hopefully that is rare. If necessary enhance to allow a list
								// of strings as the value in m_uppercaseForms, but then we may need to merge them all if we see a corresponding
								// LC form at last.
								info = m_occurrences[existingUCform];
								info.MixedCase = true;
							}
							else
							{
								// a truly new UC form, we've never seen this before. Make a new one and note the correspondence.
								info = new WordformInfo(wordform);
								m_occurrences[wordform] = info;
								m_uppercaseForms[wordformLC] = wordform;
							}
						}
					}
					else
					{
						// a new wordform, equal to its own ToLower(). Have we already seen a UC version?
						string existingUCform;
						if (m_uppercaseForms.TryGetValue(wordform, out existingUCform))
						{
							// We're seeing for the first time a lower case form of a word we've already made a list of occurrences
							// for in its upper case form.
							// Here we actually do the merging of cases. We keep using the existing WordformInfo, but change its form.
							info = m_occurrences[existingUCform];
							m_occurrences.Remove(existingUCform);
							m_occurrences[wordform] = info; // save again with different key
							info.Form = wordform; // replaces the UC form.
							info.MixedCase = true;
						}
						else
						{
							// a new LC form not matching anything; just make an entry.
							info = new WordformInfo(wordform);
							m_occurrences[wordform] = info;
						}
					}
				}
				else
				{
					// Not merging case, just make a new WordformInfo for the new form
					info = new WordformInfo(wordform);
					m_occurrences[wordform] = info;
				}
			}
			WordOccurrence item = new WordOccurrence(m_htmlFile, m_chapter, m_verse, m_anchor, m_context.Length, wordform, m_pendingNonCanonical.Count == 0);
			info.Occurrences.Add(item);
			m_pendingOccurrences.Add(item);
		}

		void AddPhraseOccurrences()
		{
			foreach (string phrase in Phrases)
			{
				int firstNonLetter;
				for (firstNonLetter = 0; firstNonLetter < phrase.Length && IsLetter(phrase[firstNonLetter]); firstNonLetter++)
					;
				if (firstNonLetter == 0 || firstNonLetter == phrase.Length)
					continue; // nothing word-like, or only one word; nothing useful we can add. Try the next phrase.
				string firstWord = phrase.Substring(0, firstNonLetter);
				WordformInfo info;
				m_occurrences.TryGetValue(firstWord, out info);
				if (info == null)
				{
					string firstWordLc = firstWord.ToLowerInvariant();
					m_occurrences.TryGetValue(firstWordLc, out info);
					if (info == null)
					{
						string existingUCForm;
						m_uppercaseForms.TryGetValue(firstWordLc, out existingUCForm);
						if (existingUCForm != null)
							m_occurrences.TryGetValue(existingUCForm, out info);
					}
				}
				if (info == null)
					continue;
				WordformInfo phraseInfo = new WordformInfo(phrase);
				string target = phrase;
				if (MergeCase)
					target = phrase.ToLowerInvariant();

				foreach (WordOccurrence wi in info.Occurrences)
				{
					string match = wi.Context.Substring(wi.Offset);
					if (MergeCase)
						match = match.ToLowerInvariant();
					if (match.StartsWith(target))
					{
						WordOccurrence phraseOccurrence = new WordOccurrence(wi.FileName, wi.Chapter, wi.Verse, wi.Anchor, wi.Offset,
						                                                     phrase, wi.Canonical);
						phraseInfo.Occurrences.Add(phraseOccurrence);
						phraseOccurrence.Context = wi.Context;
					}
				}

				if (phraseInfo.Occurrences.Count > 0)
					m_occurrences[phrase] = phraseInfo;
			}
		}

		// This version is suitable for the World English Bible format, where the CV anchors are generated by JavaScript.
		// Hence we are looking for something like <script ...>cb(2,5)/>
		//private void ProcessElement(XmlReader reader)
		//{
		//    if (reader.Name == "script")
		//    {
		//        string script = reader.ReadString().Trim().Trim(new char[] { '\n', '/', ';' });
		//        if ((script.StartsWith("cb(") || script.StartsWith("cj("))
		//            && script.EndsWith(")"))
		//        {
		//            string refSource = script.Substring(3, script.Length - 4);
		//            string[] parts = refSource.Split(',');
		//            if (parts.Length == 2)
		//            {
		//                m_chapter = Int32.Parse(parts[0]);
		//                m_verse = Int32.Parse(parts[1]);
		//            }
		//        }
		//    }
		//}

		// This version is for the OSIStoHTML converter, which inserts literal anchors <a name="C2V5"/>
        /****
		private void ProcessElement(XmlReader reader)
		{
			string className = reader.GetAttribute("class");
			m_openElementStack.Add(new NameClassPair() {Name = reader.Name, Class = className});

			// Get into 'name' the thing if any that can be an href target.
			string name = reader.GetAttribute("id");

			if (reader.Name == "a")
			{
				name = reader.GetAttribute("name");
			}

			// If we got a target remember various stuff from it.
			if (name != null && name != "") // don't clear anchor when we hit a link
			{
				m_anchor = name;
				if (name != null && name.StartsWith("C"))
				{
					string refSource = name.Substring(1, name.Length - 1); // strip off 'C'
					string[] parts = refSource.Split('V');
					if (parts.Length == 2)
					{
						m_chapter = Int32.Parse(parts[0]);
						m_verse = parts[1]; // don't try to parse this, may be complex, eg. 11-12
					}
				}
				else if (name != null && name.StartsWith("V"))
				{
					m_verse = name.Substring(1); // just strip off the "V"; don't try to parse this, may be complex, eg. 11-12a
				}
			}
			if (className != null)
			{
				if (className == "main") // Enhance JohnT: make the element that signifies this configurable.
				{
					m_chapter = 0; // start processing, but no actual number known.
				}
				if (ExcludeClasses.Contains(className))
				{
					// Prevents processing wordforms until we find the corresponding end marker.
					m_pendingExclusions.Add(reader.Name);
				}
				else if (NonCanonicalClasses.Contains(className))
				{
					if (m_pendingNonCanonical.Count == 0)
						ProcessEndOfSentence();
					m_pendingNonCanonical.Add(reader.Name);
				}
				if (className == NotesClass)
				{
					// Output no refs till we see another CV anchor
					m_verse = "";
					m_chapter = 0;
				}
			}
		}

		private void ProcessEndElement(XmlReader reader)
		{
			if (m_pendingExclusions.Count > 0 && reader.Name == m_pendingExclusions[m_pendingExclusions.Count - 1])
				m_pendingExclusions.RemoveAt(m_pendingExclusions.Count - 1);
			if (m_pendingNonCanonical.Count > 0 && reader.Name == m_pendingNonCanonical[m_pendingNonCanonical.Count - 1])
			{
				m_pendingNonCanonical.RemoveAt(m_pendingNonCanonical.Count - 1);
				if (m_pendingNonCanonical.Count == 0)
					ProcessEndOfSentence();
			}
			m_openElementStack.RemoveAt(m_openElementStack.Count - 1); // pop stack
		}
        *********/
	}
       
	// Compare wordforms using the specified string comparer.
	class WordformInfoComparer : IComparer<WordformInfo>
	{
		IComparer<string> m_comparer;

		public WordformInfoComparer(IComparer<string> comparer)
		{
			m_comparer = comparer;
		}
		#region IComparer<WordformInfo> Members

		public int Compare(WordformInfo x, WordformInfo y)
		{
			return m_comparer.Compare(x.Form, y.Form);
		}

		#endregion
	}
}
